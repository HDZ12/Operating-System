协调进程间的相互制约关系，使他们按照预期的方式执行的过程
- 前提
	- 进程是并发执行的。进程间存在相互制约关系
	- 并发的就能成对系统共享资源进行竞争
	- 进程通信。过程中相互发送的信号成文消息，或事件
- 两种相互制约关系
	- 间接相互制约关系（互斥）：进程排他性的访问共享资源
	- 直接相互制约关系（同步）：进程间的和作，比如管道通信 
- 访问过程：
	- 进入区：尝试进入临界区，成功则加锁（lock)
	- 临界区：访问共享资源
	- 退出区：解锁(unlock),唤醒其他阻塞进程
	- 剩余区
	- 
	- 
	- 

 - 访问原则
	 - 空闲让进：临界区空闲。允许一个进程进入
	 - 忙则等待：临界区已有进程，其他进程等待
	 - 有限等待：处于等待的进程，等待时间有限
	 - 让权等待：等待时让出CPU执行权，防止忙等待  
- 互斥的访问临界资源：
	- 软件实现：
		- 单标志法：违背空闲让进
			- p0:`while(turn!=0);critical section;turn =1;remainder section;`
			- p1:`while(turn!=1);critical section;turn=0;remainder section;`
		- 双标志法先检查：违背忙则等待
			- p0:`bool flag[2];while(flag[1]);flag[0]=true;critical sectin;flag[0]=false;remainder section`
			-  p1:`while(flag[0]);flag[1]=true;critical section;flag[1]=false;remainder section;` 
		- 双标执法后检查：违背空闲让进，优先等待，现赋值，后检查
		- 皮特森算法：违背让权等待，会发生忙等
			- falg[0]=true;turn=1;while(flag[0]&&turn==1); 
	- 硬件算法：
		- 中断屏蔽：关中断/开中断
			- 禁止一切中断 ，CPU执行完临界区之前不会切换
			- 关中断可能会被滥用
			- 关中断时间长影响效率
			- 不适用于多处理机，无法防止其他处理机调度其他进程访问临界区
			- 只适用于
			- 
			- 
			- 内核进程（该指令运行在内核态）
		- Test-And-set(TS/TSL)
			- 读出标志并设置为true,返回旧值，原子操作
			- 也被称作TSL指令
			- 违背让权等待，会发生忙等   
		- Swap指令（EXCHANGE,XCHG指令）
			- 交换两个变量的值
			- 违背让权等待 
- 信号量（semaphore)机制
	- pv操作
		- p操作：wait原语，进程等待
		- v操作：signal原语，唤醒等待操作
	 - 整型信号量：违背让权等待，会发生忙等。 
	 - `int s=0;void wait(int s){while(s<=0);s=s-1;}void signal(int s){s=s+1;}`
	 - 记录信号量：进程进入阻塞状态，不会忙等。  
- 管程：进程同步的工具（Montior，监视器）
	- 组成：
		- 管程名称
		- 局部与管理内部的共享数据结构
		- 对该数据结构操作的一组过程
		- 管程内共享数据的初始化语句  
	- 基本特性：
		- 是一个模块化的基本程序单位，可以单独编译
		- 是一种抽象数据类型，包含数据和操作
		- 信息掩蔽，共享数据只能被管程内的过程访问 
- 死锁
	- 死锁的概念
		- 定义：多个进程由于竞争资源而造成的阻塞现象，若无外力作用，这些进程将无法继续推进。
		- 饥饿：等待时间过长，“饿而不死”
		- 产生原因 
			- 系统资源的竞争
			- 进程推进顺序非法  
	- 死锁产生的条件
		- 互斥的条件：共享资源的排他访问
		- 不剥夺条件：访问该共享资源不会被剥夺
		- 请求并保持条件：保持当前资源时请求另一个资源
		- 循环等待条件：存在共享资源的循环等待链

	 
		